import { OAuth2Strategy } from "remix-auth-oauth2";
import { redirect } from "@remix-run/server-runtime";
import isbot from "isbot";
import crypto from "crypto";

type ShopifyAppAuthStrategyOptions = {
  api: {
    key: string;
    secret: string;
    scopes: string;
    version: string;
  };
  urls: {
    app: string;
    store: string;
    auth: {
      authorization: string;
      callback: string;
    };
  };
  tokenStorage: {
    getToken: (storeFQDN: string) => Promise<string>;
    setToken: (storeFQDN: string, token: string) => Promise<void>;
  };
  hooks?: {
    onAuthCompleted?: (context: ShopifyAuthenticatedContext) => Promise<void>;
  };
};

type ShopifyAuthenticatedContext = {
  admin: {
    fetch: (path: string, opts: any) => Promise<any>;
    mutate: (query: string, variables: any) => Promise<any>;
    query: (query: string) => Promise<any>;
  };
};

type ShopifyAppWebhookAuthStrategyOptions = {
  api: {
    secret: string;
    key: string;
    version: string;
  };
  urls: {
    webhooks: string;
  };
  webhooks: {
    topics: string[];
  };
  tokenStorage: {
    getToken: (storeFQDN: string) => Promise<string>;
  };
};

export class ShopifyAppWebhookAuthStrategy extends OAuth2Strategy<
  any,
  any,
  any
> {
  options: ShopifyAppWebhookAuthStrategyOptions;

  constructor(options: ShopifyAppWebhookAuthStrategyOptions) {
    super({} as any, (() => {}) as any);
    this.options = options;
  }

  async authenticate(request: any, sessionStorage: any, options: any) {
    if (isbot(request.headers.get("User-Agent"))) {
      // @ts-ignore
      throw new Response(null, { status: 400 });
    }

    const topic: string = request.headers.get("X-Shopify-Topic");
    const storeFQDN = request.headers.get("X-Shopify-Shop-Domain");
    const rawBody = await request.text();
    const headerHash = request.headers.get("X-Shopify-Hmac-Sha256");
    const bodyHash = await crypto
      .createHmac("sha256", this.options.api.secret)
      .update(rawBody)
      .digest("base64");
    if (headerHash !== bodyHash) {
      // @ts-ignore
      throw new Response(null, {
        status: 401,
      });
    }
    const storeToken = storeFQDN
      ? await this.options.tokenStorage.getToken(storeFQDN)
      : null;
    if (!storeToken) {
      // @ts-ignore
      throw new Response(null, {
        status: 200,
      });
    }
    return this.success(
      {
        ...getAuthenticatedContext({
          storeFQDN,
          storeToken,
          apiKey: this.options.api.key,
          apiVersion: this.options.api.version,
        }),
        topic: topic.replace("/", "_").toUpperCase(),
        payload: JSON.parse(rawBody),
      },
      request,
      sessionStorage,
      options
    );
  }

  async subscribeToTopics({ admin }: any) {
    const webhookSubscriptionCreateMutation = `mutation webhookSubscriptionCreate($topic: WebhookSubscriptionTopic!, $webhookSubscription: WebhookSubscriptionInput!) {
      webhookSubscriptionCreate(topic: $topic, webhookSubscription: $webhookSubscription) {
        userErrors {
          field
          message
        }
        webhookSubscription {
          createdAt
        }
      }
    }`;
    const webhookSubscriptionDeleteMutation = `mutation webhookSubscriptionDelete($id: ID!) {
      webhookSubscriptionDelete(id: $id) {
        userErrors {
          field
          message
        }
      }
    }
    `;
    const getWebhookSubscriptionsQuery = `{
      webhookSubscriptions(
        first: 250,
      ) {
        edges {
          node {
            id
            topic
          }
        }
        pageInfo {
          endCursor
          hasNextPage
        }
      }
    }`;

    const response = await admin.query(getWebhookSubscriptionsQuery);

    await Promise.all(
      response.data.webhookSubscriptions.edges.map((edge: any) => {
        return admin.mutate(webhookSubscriptionDeleteMutation, {
          id: edge.node.id,
        });
      })
    );

    await Promise.all(
      this.options.webhooks.topics.map((topic) => {
        if (topic !== "") {
          return admin.mutate(webhookSubscriptionCreateMutation, {
            topic: topic,
            webhookSubscription: {
              callbackUrl: this.options.urls.webhooks,
              format: "JSON",
            },
          });
        }
      })
    );
  }
}

export class ShopifyAppAuthStrategy extends OAuth2Strategy<any, any, any> {
  options: ShopifyAppAuthStrategyOptions;

  constructor(options: ShopifyAppAuthStrategyOptions) {
    super(
      {
        clientID: options.api.key,
        clientSecret: options.api.secret,
        authorizationURL: options.urls.auth.authorization,
        tokenURL: new URL(
          "/admin/oauth/access_token",
          options.urls.store
        ).toString(),
        callbackURL: options.urls.auth.callback,
      },
      (() => {}) as any
    );
    this.options = options;
  }

  authorizationParams() {
    // @ts-ignore
    const params = super.authorizationParams();
    params.set("scope", this.options.api.scopes);
    return params;
  }

  async redirectToAuth(request: any, sessionStorage: any, options: any) {
    // @ts-ignore
    let state = this.generateState();
    const session = await sessionStorage.getSession(
      request.headers.get("Cookie")
    );
    // @ts-ignore
    session.set(this.sessionStateKey, state);
    // @ts-ignore
    // @ts-ignore
    throw redirect(this.getAuthorizationURL(request, state).toString(), {
      headers: { "Set-Cookie": await sessionStorage.commitSession(session) },
    });
  }

  async authenticate(request: any, sessionStorage: any, options: any) {
    if (isbot(request.headers.get("User-Agent"))) {
      // @ts-ignore
      throw new Response(null, { status: 400 });
    }

    let url = new URL(request.url);
    url.protocol = "https:";

    const isBouncePage = url.pathname.startsWith("/auth/session-token");
    const hasSessionTokenInHeaders = request?.headers?.get(
      "x-shopify-session-token"
    );
    const isAuthRequest = url.pathname.startsWith("/auth");

    if (isBouncePage) {
      // @ts-ignore
      throw new Response(
        `<script data-api-key="${this.options.api.key}" src="https://cdn.shopify.com/shopifycloud/app-bridge-next/app-bridge.js"></script>`,
        { headers: { "content-type": "text/html;charset=utf-8" } }
      );
    }

    if (isAuthRequest) {
      return await this.handleAuthRequest(request, sessionStorage, options);
    } else if (hasSessionTokenInHeaders) {
      return await this.verifySessionToken(request, sessionStorage, options);
    } else {
      const storeFQDN = url.searchParams.get("shop") as string;
      if (!storeFQDN) {
        throw new Error("Shop param is not present");
      }
      const storeToken = storeFQDN
        ? await this.options.tokenStorage.getToken(storeFQDN)
        : null;
      if (storeToken) {
        return await this.redirectToBouncePage(url);
      } else {
        return await this.redirectToAuth(request, sessionStorage, options);
      }
    }
  }

  async verifySessionToken(request: any, sessionStorage: any, options: any) {
    const sessionToken = request.headers.get("x-shopify-session-token");
    const { default: jwt } = await import("jsonwebtoken");
    const payload = jwt.verify(sessionToken, this.options.api.secret);
    // @ts-ignore
    const storeFQDN = payload.dest.replace(/^https:\/\//, "");
    const storeToken = await this.options.tokenStorage.getToken(storeFQDN);

    if (storeToken) {
      return this.success(
        getAuthenticatedContext({
          storeFQDN,
          storeToken,
          apiKey: this.options.api.key,
          apiVersion: this.options.api.version,
        }),
        request,
        sessionStorage,
        options
      );
    } else {
      await this.redirectToAuth(request, sessionStorage, options);
    }
  }

  async handleAuthorizeRequest(
    request: any,
    sessionStorage: any,
    options: any
  ) {
    let url = new URL(request.url);
    url.protocol = "https:";

    const storeFQDN = url.searchParams.get("shop") as string;
    if (!storeFQDN) {
      await this.redirectToAuth(request, sessionStorage, options);
    }
    const storeToken = await this.options.tokenStorage.getToken(storeFQDN);
    if (!storeToken) {
      await this.redirectToAuth(request, sessionStorage, options);
    }
    const isEmbedded = url.searchParams.get("embedded") === "1";
    if (!storeToken) {
      if (isEmbedded) {
        // TODO: Implement the exitiframe
        await this.redirectToAuth(request, sessionStorage, options);
      } else {
        await this.redirectToAuth(request, sessionStorage, options);
      }
    } else {
      return this.success(
        getAuthenticatedContext({
          storeFQDN,
          storeToken,
          apiKey: this.options.api.key,
          apiVersion: this.options.api.version,
        }),
        request,
        sessionStorage,
        options
      );
    }
  }

  async handleCallbackRequest(request: any, sessionStorage: any, options: any) {
    let url = new URL(request.url);
    url.protocol = "https:";

    let urlState = url.searchParams.get("state");

    if (!urlState) {
      throw new Error("Missing state on URL.");
    }

    // @ts-ignore
    const session = await sessionStorage.getSession(
      request.headers.get("Cookie")
    );
    // @ts-ignore
    let stateSession = session.get(this.sessionStateKey);
    if (!stateSession) {
      throw new Error("Missing state on session.");
    }

    if (stateSession === urlState) {
      const session = await sessionStorage.getSession(
        request.headers.get("Cookie")
      );
      // @ts-ignore
      session.unset(this.sessionStateKey);
    } else {
      throw new Error("State doesn't match.");
    }

    let code = url.searchParams.get("code");

    if (!code) {
      throw new Error("Missing code.");
    }

    let params = new URLSearchParams(this.tokenParams());
    params.set("grant_type", "authorization_code");
    // @ts-ignore
    let callbackURL = this.getCallbackURL(url);
    params.set("redirect_uri", callbackURL.toString());

    // @ts-ignore
    const { accessToken } = await this.fetchAccessToken(code, params);
    // @ts-ignore
    const storeFQDN = url.searchParams.get("shop") as string;
    await this.options.tokenStorage.setToken(storeFQDN, accessToken);

    if (this.options.hooks?.onAuthCompleted) {
      const context = getAuthenticatedContext({
        storeFQDN,
        storeToken: accessToken,
        apiKey: this.options.api.key,
        apiVersion: this.options.api.version,
      });
      this.options.hooks?.onAuthCompleted(context);
    }
    this.redirectToBouncePage(url, "/");
  }

  async handleAuthRequest(request: any, sessionStorage: any, options: any) {
    let url = new URL(request.url);
    url.protocol = "https:";

    // @ts-ignore
    let callbackURL = this.getCallbackURL(url);
    if (url.pathname !== callbackURL.pathname) {
      await this.handleAuthorizeRequest(request, sessionStorage, options);
    } else {
      await this.handleCallbackRequest(request, sessionStorage, options);
    }
  }

  redirectToBouncePage(url: URL, redirectTo: string | undefined = undefined) {
    const params = new URLSearchParams(url.search);
    params.set("redirectTo", redirectTo ?? url.href);
    const redirectURL = `/auth/session-token?${params.toString()}`;
    throw redirect(redirectURL);
  }

  getNonAuthenticatedContext() {
    return {
      apiKey: this.options.api.key,
    };
  }
}

type GetAuthenticatedContextOptions = {
  storeFQDN: string;
  storeToken: string;
  apiKey: string;
  apiVersion: string;
};

export function getAuthenticatedContext(
  options: GetAuthenticatedContextOptions
): ShopifyAuthenticatedContext {
  return {
    admin: {
      fetch: async (path: string, opts: any) => {
        // @ts-ignore
        const url = `https://${options.storeFQDN}/admin/api/${options.apiVersion}${path}`;

        // @ts-ignore
        const req = new Request(url, opts);
        req.headers.set("X-Shopify-Access-Token", options.storeToken);
        req.headers.set("Content-Type", "application/json");
        // @ts-expect-error We are binding fetch to the this context
        const responseJson = await (await fetch.call(this, req)).json();
        return responseJson;
      },

      mutate: async (query: string, variables: any) => {
        // @ts-ignore
        const url = `https://${options.storeFQDN}/admin/api/${options.apiVersion}/graphql.json`;

        // @ts-ignore
        const req = new Request(url, {
          method: "POST",
          body: JSON.stringify({
            query,
            variables: variables || undefined,
          }),
        });
        req.headers.set("X-Shopify-Access-Token", options.storeToken);
        req.headers.set("Content-Type", "application/json");
        // @ts-expect-error We are binding fetch to the this context
        const responseJson = await (await fetch.call(this, req)).json();
        return responseJson;
      },
      query: async (query: string) => {
        // @ts-ignore
        const url = `https://${options.storeFQDN}/admin/api/${options.apiVersion}/graphql.json`;
        // @ts-ignore
        const req = new Request(url, {
          method: "POST",
          body: JSON.stringify({
            query,
          }),
        });
        req.headers.set("X-Shopify-Access-Token", options.storeToken);
        req.headers.set("Content-Type", "application/json");
        // @ts-expect-error We are binding fetch to the this context
        const response = await fetch.call(this, req);
        const responseJson = await response.json();
        return responseJson;
      },
    },
  };
}
